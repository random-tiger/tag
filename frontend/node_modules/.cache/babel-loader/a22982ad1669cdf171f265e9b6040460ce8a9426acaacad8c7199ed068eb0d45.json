{"ast":null,"code":"var _jsxFileName = \"/Users/bbassett/simple/frontend/src/contexts/StoryContext.js\",\n  _s = $RefreshSig$(),\n  _s2 = $RefreshSig$();\nimport React, { createContext, useContext, useReducer, useEffect, useRef } from 'react';\nimport { apiClient } from '../services/api';\nimport toast from 'react-hot-toast';\n\n// Initial state\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst initialState = {\n  stories: [],\n  currentStory: null,\n  loading: false,\n  error: null,\n  generationStatus: {}\n};\n\n// Action types\nconst ActionTypes = {\n  SET_LOADING: 'SET_LOADING',\n  SET_ERROR: 'SET_ERROR',\n  SET_STORIES: 'SET_STORIES',\n  SET_CURRENT_STORY: 'SET_CURRENT_STORY',\n  ADD_STORY: 'ADD_STORY',\n  UPDATE_STORY: 'UPDATE_STORY',\n  UPDATE_GENERATION_STATUS: 'UPDATE_GENERATION_STATUS',\n  CLEAR_ERROR: 'CLEAR_ERROR'\n};\n\n// Reducer\nfunction storyReducer(state, action) {\n  var _state$currentStory;\n  switch (action.type) {\n    case ActionTypes.SET_LOADING:\n      return {\n        ...state,\n        loading: action.payload\n      };\n    case ActionTypes.SET_ERROR:\n      return {\n        ...state,\n        error: action.payload,\n        loading: false\n      };\n    case ActionTypes.CLEAR_ERROR:\n      return {\n        ...state,\n        error: null\n      };\n    case ActionTypes.SET_STORIES:\n      return {\n        ...state,\n        stories: action.payload,\n        loading: false\n      };\n    case ActionTypes.SET_CURRENT_STORY:\n      return {\n        ...state,\n        currentStory: action.payload,\n        loading: false\n      };\n    case ActionTypes.ADD_STORY:\n      return {\n        ...state,\n        stories: [action.payload, ...state.stories],\n        loading: false\n      };\n    case ActionTypes.UPDATE_STORY:\n      return {\n        ...state,\n        stories: state.stories.map(story => story.id === action.payload.id ? action.payload : story),\n        currentStory: ((_state$currentStory = state.currentStory) === null || _state$currentStory === void 0 ? void 0 : _state$currentStory.id) === action.payload.id ? action.payload : state.currentStory,\n        loading: false\n      };\n    case ActionTypes.UPDATE_GENERATION_STATUS:\n      return {\n        ...state,\n        generationStatus: {\n          ...state.generationStatus,\n          [action.payload.operationId]: action.payload.status\n        }\n      };\n    default:\n      return state;\n  }\n}\n\n// Create context\nconst StoryContext = /*#__PURE__*/createContext();\n\n// Provider component\nexport function StoryProvider({\n  children\n}) {\n  _s();\n  const [state, dispatch] = useReducer(storyReducer, initialState);\n  const activePollsRef = useRef(new Set());\n\n  // Helper function to handle API errors\n  const handleApiError = (error, defaultMessage = 'An error occurred') => {\n    var _error$response, _error$response$data;\n    const message = (error === null || error === void 0 ? void 0 : (_error$response = error.response) === null || _error$response === void 0 ? void 0 : (_error$response$data = _error$response.data) === null || _error$response$data === void 0 ? void 0 : _error$response$data.error) || (error === null || error === void 0 ? void 0 : error.message) || defaultMessage;\n    dispatch({\n      type: ActionTypes.SET_ERROR,\n      payload: message\n    });\n    toast.error(message);\n  };\n\n  // Load stories\n  const loadStories = async (userId = 'anonymous') => {\n    try {\n      dispatch({\n        type: ActionTypes.SET_LOADING,\n        payload: true\n      });\n      dispatch({\n        type: ActionTypes.CLEAR_ERROR\n      });\n      const response = await apiClient.get(`/stories?user_id=${userId}`);\n      dispatch({\n        type: ActionTypes.SET_STORIES,\n        payload: response.data.stories\n      });\n    } catch (error) {\n      handleApiError(error, 'Failed to load stories');\n    }\n  };\n\n  // Create new story\n  const createStory = async (title, description = '', userId = 'anonymous') => {\n    try {\n      dispatch({\n        type: ActionTypes.SET_LOADING,\n        payload: true\n      });\n      dispatch({\n        type: ActionTypes.CLEAR_ERROR\n      });\n      const response = await apiClient.post('/stories', {\n        title,\n        description,\n        user_id: userId\n      });\n      dispatch({\n        type: ActionTypes.ADD_STORY,\n        payload: response.data\n      });\n      toast.success('Story created successfully!');\n      return response.data;\n    } catch (error) {\n      handleApiError(error, 'Failed to create story');\n      throw error;\n    }\n  };\n\n  // Load specific story\n  const loadStory = async storyId => {\n    try {\n      dispatch({\n        type: ActionTypes.SET_LOADING,\n        payload: true\n      });\n      dispatch({\n        type: ActionTypes.CLEAR_ERROR\n      });\n      const response = await apiClient.get(`/stories/${storyId}`);\n      dispatch({\n        type: ActionTypes.SET_CURRENT_STORY,\n        payload: response.data\n      });\n      // Auto-resume polling for any in-progress segments when loading a story\n      resumePollingForStory(response.data);\n      return response.data;\n    } catch (error) {\n      handleApiError(error, 'Failed to load story');\n      throw error;\n    }\n  };\n\n  // Generate video segment\n  const generateVideoSegment = async (storyId, prompt, imageFile = null, usePreviousFrame = false) => {\n    try {\n      dispatch({\n        type: ActionTypes.SET_LOADING,\n        payload: true\n      });\n      dispatch({\n        type: ActionTypes.CLEAR_ERROR\n      });\n      const formData = new FormData();\n      formData.append('prompt', prompt);\n      formData.append('use_previous_frame', usePreviousFrame.toString());\n      if (imageFile) {\n        formData.append('image', imageFile);\n      }\n      const response = await apiClient.post(`/stories/${storyId}/generate`, formData, {\n        headers: {\n          'Content-Type': 'multipart/form-data'\n        }\n      });\n\n      // Start polling for status updates\n      startStatusPolling(response.data.operation_id);\n      toast.success('Video generation started!');\n      dispatch({\n        type: ActionTypes.SET_LOADING,\n        payload: false\n      });\n      return response.data;\n    } catch (error) {\n      handleApiError(error, 'Failed to start video generation');\n      throw error;\n    }\n  };\n\n  // Stitch story videos\n  const stitchStory = async storyId => {\n    try {\n      dispatch({\n        type: ActionTypes.SET_LOADING,\n        payload: true\n      });\n      dispatch({\n        type: ActionTypes.CLEAR_ERROR\n      });\n      const response = await apiClient.post(`/stories/${storyId}/stitch`);\n\n      // Reload the story to get updated data\n      await loadStory(storyId);\n      toast.success('Story stitched successfully!');\n      return response.data;\n    } catch (error) {\n      handleApiError(error, 'Failed to stitch story');\n      throw error;\n    }\n  };\n\n  // Delete a story\n  const deleteStory = async storyId => {\n    try {\n      dispatch({\n        type: ActionTypes.SET_LOADING,\n        payload: true\n      });\n      dispatch({\n        type: ActionTypes.CLEAR_ERROR\n      });\n      await apiClient.delete(`/stories/${storyId}`);\n      toast.success('Story deleted');\n      await loadStories();\n    } catch (error) {\n      handleApiError(error, 'Failed to delete story');\n      throw error;\n    }\n  };\n\n  // Delete a single segment\n  const deleteSegment = async (segmentId, storyId) => {\n    try {\n      dispatch({\n        type: ActionTypes.CLEAR_ERROR\n      });\n      await apiClient.delete(`/segments/${segmentId}`);\n      toast.success('Segment deleted');\n      if (storyId) await loadStory(storyId);\n    } catch (error) {\n      handleApiError(error, 'Failed to delete segment');\n      throw error;\n    }\n  };\n\n  // AI prompt assistance\n  const assistPrompt = async (storyId, payload) => {\n    try {\n      dispatch({\n        type: ActionTypes.CLEAR_ERROR\n      });\n      const response = await apiClient.post(`/stories/${storyId}/prompt-assist`, payload);\n      return response.data;\n    } catch (error) {\n      handleApiError(error, 'Failed to get AI assistance');\n      throw error;\n    }\n  };\n\n  // Start polling for generation status\n  const startStatusPolling = operationId => {\n    // Avoid duplicate pollers per operation\n    if (activePollsRef.current.has(operationId)) return;\n    activePollsRef.current.add(operationId);\n    const pollInterval = setInterval(async () => {\n      try {\n        const response = await apiClient.get(`/generation-status/${operationId}`);\n        const status = response.data;\n        dispatch({\n          type: ActionTypes.UPDATE_GENERATION_STATUS,\n          payload: {\n            operationId,\n            status\n          }\n        });\n        if (status.status === 'completed') {\n          clearInterval(pollInterval);\n          activePollsRef.current.delete(operationId);\n          toast.success('Video generation completed!');\n\n          // Reload current story if it matches\n          if (state.currentStory && status.segment_id) {\n            loadStory(state.currentStory.id);\n          }\n        } else if (status.status === 'failed') {\n          clearInterval(pollInterval);\n          activePollsRef.current.delete(operationId);\n          toast.error(`Video generation failed: ${status.error || 'Unknown error'}`);\n        }\n      } catch (error) {\n        // Silently handle polling errors to avoid spam\n        console.error('Status polling error:', error);\n        clearInterval(pollInterval);\n        activePollsRef.current.delete(operationId);\n      }\n    }, 15000); // Poll every 15 seconds\n\n    // Clear polling after 10 minutes\n    setTimeout(() => {\n      clearInterval(pollInterval);\n      activePollsRef.current.delete(operationId);\n    }, 600000);\n  };\n\n  // Resume polling helper for a story object\n  const resumePollingForStory = story => {\n    try {\n      const segments = Array.isArray(story === null || story === void 0 ? void 0 : story.segments) ? story.segments : [];\n      segments.filter(seg => (seg.status === 'generating' || seg.status === 'publishing') && !!seg.operation_id).forEach(seg => startStatusPolling(seg.operation_id));\n    } catch (e) {\n      // no-op\n    }\n  };\n\n  // Context value\n  const contextValue = {\n    ...state,\n    actions: {\n      loadStories,\n      createStory,\n      loadStory,\n      generateVideoSegment,\n      stitchStory,\n      deleteStory,\n      deleteSegment,\n      assistPrompt,\n      clearError: () => dispatch({\n        type: ActionTypes.CLEAR_ERROR\n      })\n    }\n  };\n  return /*#__PURE__*/_jsxDEV(StoryContext.Provider, {\n    value: contextValue,\n    children: children\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 315,\n    columnNumber: 5\n  }, this);\n}\n\n// Hook to use the story context\n_s(StoryProvider, \"7cIkmGRhzoQvirh6eg6XBSnJWP8=\");\n_c = StoryProvider;\nexport function useStory() {\n  _s2();\n  const context = useContext(StoryContext);\n  if (!context) {\n    throw new Error('useStory must be used within a StoryProvider');\n  }\n  return context;\n}\n_s2(useStory, \"b9L3QQ+jgeyIrH0NfHrJ8nn7VMU=\");\nvar _c;\n$RefreshReg$(_c, \"StoryProvider\");","map":{"version":3,"names":["React","createContext","useContext","useReducer","useEffect","useRef","apiClient","toast","jsxDEV","_jsxDEV","initialState","stories","currentStory","loading","error","generationStatus","ActionTypes","SET_LOADING","SET_ERROR","SET_STORIES","SET_CURRENT_STORY","ADD_STORY","UPDATE_STORY","UPDATE_GENERATION_STATUS","CLEAR_ERROR","storyReducer","state","action","_state$currentStory","type","payload","map","story","id","operationId","status","StoryContext","StoryProvider","children","_s","dispatch","activePollsRef","Set","handleApiError","defaultMessage","_error$response","_error$response$data","message","response","data","loadStories","userId","get","createStory","title","description","post","user_id","success","loadStory","storyId","resumePollingForStory","generateVideoSegment","prompt","imageFile","usePreviousFrame","formData","FormData","append","toString","headers","startStatusPolling","operation_id","stitchStory","deleteStory","delete","deleteSegment","segmentId","assistPrompt","current","has","add","pollInterval","setInterval","clearInterval","segment_id","console","setTimeout","segments","Array","isArray","filter","seg","forEach","e","contextValue","actions","clearError","Provider","value","fileName","_jsxFileName","lineNumber","columnNumber","_c","useStory","_s2","context","Error","$RefreshReg$"],"sources":["/Users/bbassett/simple/frontend/src/contexts/StoryContext.js"],"sourcesContent":["import React, { createContext, useContext, useReducer, useEffect, useRef } from 'react';\nimport { apiClient } from '../services/api';\nimport toast from 'react-hot-toast';\n\n// Initial state\nconst initialState = {\n  stories: [],\n  currentStory: null,\n  loading: false,\n  error: null,\n  generationStatus: {},\n};\n\n// Action types\nconst ActionTypes = {\n  SET_LOADING: 'SET_LOADING',\n  SET_ERROR: 'SET_ERROR',\n  SET_STORIES: 'SET_STORIES',\n  SET_CURRENT_STORY: 'SET_CURRENT_STORY',\n  ADD_STORY: 'ADD_STORY',\n  UPDATE_STORY: 'UPDATE_STORY',\n  UPDATE_GENERATION_STATUS: 'UPDATE_GENERATION_STATUS',\n  CLEAR_ERROR: 'CLEAR_ERROR',\n};\n\n// Reducer\nfunction storyReducer(state, action) {\n  switch (action.type) {\n    case ActionTypes.SET_LOADING:\n      return { ...state, loading: action.payload };\n    \n    case ActionTypes.SET_ERROR:\n      return { ...state, error: action.payload, loading: false };\n    \n    case ActionTypes.CLEAR_ERROR:\n      return { ...state, error: null };\n    \n    case ActionTypes.SET_STORIES:\n      return { ...state, stories: action.payload, loading: false };\n    \n    case ActionTypes.SET_CURRENT_STORY:\n      return { ...state, currentStory: action.payload, loading: false };\n    \n    case ActionTypes.ADD_STORY:\n      return { \n        ...state, \n        stories: [action.payload, ...state.stories], \n        loading: false \n      };\n    \n    case ActionTypes.UPDATE_STORY:\n      return {\n        ...state,\n        stories: state.stories.map(story => \n          story.id === action.payload.id ? action.payload : story\n        ),\n        currentStory: state.currentStory?.id === action.payload.id \n          ? action.payload \n          : state.currentStory,\n        loading: false\n      };\n    \n    case ActionTypes.UPDATE_GENERATION_STATUS:\n      return {\n        ...state,\n        generationStatus: {\n          ...state.generationStatus,\n          [action.payload.operationId]: action.payload.status\n        }\n      };\n    \n    default:\n      return state;\n  }\n}\n\n// Create context\nconst StoryContext = createContext();\n\n// Provider component\nexport function StoryProvider({ children }) {\n  const [state, dispatch] = useReducer(storyReducer, initialState);\n  const activePollsRef = useRef(new Set());\n\n  // Helper function to handle API errors\n  const handleApiError = (error, defaultMessage = 'An error occurred') => {\n    const message = error?.response?.data?.error || error?.message || defaultMessage;\n    dispatch({ type: ActionTypes.SET_ERROR, payload: message });\n    toast.error(message);\n  };\n\n  // Load stories\n  const loadStories = async (userId = 'anonymous') => {\n    try {\n      dispatch({ type: ActionTypes.SET_LOADING, payload: true });\n      dispatch({ type: ActionTypes.CLEAR_ERROR });\n      \n      const response = await apiClient.get(`/stories?user_id=${userId}`);\n      dispatch({ type: ActionTypes.SET_STORIES, payload: response.data.stories });\n      \n    } catch (error) {\n      handleApiError(error, 'Failed to load stories');\n    }\n  };\n\n  // Create new story\n  const createStory = async (title, description = '', userId = 'anonymous') => {\n    try {\n      dispatch({ type: ActionTypes.SET_LOADING, payload: true });\n      dispatch({ type: ActionTypes.CLEAR_ERROR });\n      \n      const response = await apiClient.post('/stories', {\n        title,\n        description,\n        user_id: userId\n      });\n      \n      dispatch({ type: ActionTypes.ADD_STORY, payload: response.data });\n      toast.success('Story created successfully!');\n      \n      return response.data;\n      \n    } catch (error) {\n      handleApiError(error, 'Failed to create story');\n      throw error;\n    }\n  };\n\n  // Load specific story\n  const loadStory = async (storyId) => {\n    try {\n      dispatch({ type: ActionTypes.SET_LOADING, payload: true });\n      dispatch({ type: ActionTypes.CLEAR_ERROR });\n      \n      const response = await apiClient.get(`/stories/${storyId}`);\n      dispatch({ type: ActionTypes.SET_CURRENT_STORY, payload: response.data });\n      // Auto-resume polling for any in-progress segments when loading a story\n      resumePollingForStory(response.data);\n      \n      return response.data;\n      \n    } catch (error) {\n      handleApiError(error, 'Failed to load story');\n      throw error;\n    }\n  };\n\n  // Generate video segment\n  const generateVideoSegment = async (storyId, prompt, imageFile = null, usePreviousFrame = false) => {\n    try {\n      dispatch({ type: ActionTypes.SET_LOADING, payload: true });\n      dispatch({ type: ActionTypes.CLEAR_ERROR });\n      \n      const formData = new FormData();\n      formData.append('prompt', prompt);\n      formData.append('use_previous_frame', usePreviousFrame.toString());\n      \n      if (imageFile) {\n        formData.append('image', imageFile);\n      }\n      \n      const response = await apiClient.post(`/stories/${storyId}/generate`, formData, {\n        headers: {\n          'Content-Type': 'multipart/form-data'\n        }\n      });\n      \n      // Start polling for status updates\n      startStatusPolling(response.data.operation_id);\n      \n      toast.success('Video generation started!');\n      dispatch({ type: ActionTypes.SET_LOADING, payload: false });\n      \n      return response.data;\n      \n    } catch (error) {\n      handleApiError(error, 'Failed to start video generation');\n      throw error;\n    }\n  };\n\n  // Stitch story videos\n  const stitchStory = async (storyId) => {\n    try {\n      dispatch({ type: ActionTypes.SET_LOADING, payload: true });\n      dispatch({ type: ActionTypes.CLEAR_ERROR });\n      \n      const response = await apiClient.post(`/stories/${storyId}/stitch`);\n      \n      // Reload the story to get updated data\n      await loadStory(storyId);\n      \n      toast.success('Story stitched successfully!');\n      \n      return response.data;\n      \n    } catch (error) {\n      handleApiError(error, 'Failed to stitch story');\n      throw error;\n    }\n  };\n\n  // Delete a story\n  const deleteStory = async (storyId) => {\n    try {\n      dispatch({ type: ActionTypes.SET_LOADING, payload: true });\n      dispatch({ type: ActionTypes.CLEAR_ERROR });\n      await apiClient.delete(`/stories/${storyId}`);\n      toast.success('Story deleted');\n      await loadStories();\n    } catch (error) {\n      handleApiError(error, 'Failed to delete story');\n      throw error;\n    }\n  };\n\n  // Delete a single segment\n  const deleteSegment = async (segmentId, storyId) => {\n    try {\n      dispatch({ type: ActionTypes.CLEAR_ERROR });\n      await apiClient.delete(`/segments/${segmentId}`);\n      toast.success('Segment deleted');\n      if (storyId) await loadStory(storyId);\n    } catch (error) {\n      handleApiError(error, 'Failed to delete segment');\n      throw error;\n    }\n  };\n\n  // AI prompt assistance\n  const assistPrompt = async (storyId, payload) => {\n    try {\n      dispatch({ type: ActionTypes.CLEAR_ERROR });\n      const response = await apiClient.post(`/stories/${storyId}/prompt-assist`, payload);\n      return response.data;\n    } catch (error) {\n      handleApiError(error, 'Failed to get AI assistance');\n      throw error;\n    }\n  };\n\n  // Start polling for generation status\n  const startStatusPolling = (operationId) => {\n    // Avoid duplicate pollers per operation\n    if (activePollsRef.current.has(operationId)) return;\n    activePollsRef.current.add(operationId);\n\n    const pollInterval = setInterval(async () => {\n      try {\n        const response = await apiClient.get(`/generation-status/${operationId}`);\n        const status = response.data;\n        \n        dispatch({\n          type: ActionTypes.UPDATE_GENERATION_STATUS,\n          payload: { operationId, status }\n        });\n        \n        if (status.status === 'completed') {\n          clearInterval(pollInterval);\n          activePollsRef.current.delete(operationId);\n          toast.success('Video generation completed!');\n          \n          // Reload current story if it matches\n          if (state.currentStory && status.segment_id) {\n            loadStory(state.currentStory.id);\n          }\n          \n        } else if (status.status === 'failed') {\n          clearInterval(pollInterval);\n          activePollsRef.current.delete(operationId);\n          toast.error(`Video generation failed: ${status.error || 'Unknown error'}`);\n        }\n        \n      } catch (error) {\n        // Silently handle polling errors to avoid spam\n        console.error('Status polling error:', error);\n        clearInterval(pollInterval);\n        activePollsRef.current.delete(operationId);\n      }\n    }, 15000); // Poll every 15 seconds\n    \n    // Clear polling after 10 minutes\n    setTimeout(() => { clearInterval(pollInterval); activePollsRef.current.delete(operationId); }, 600000);\n  };\n\n  // Resume polling helper for a story object\n  const resumePollingForStory = (story) => {\n    try {\n      const segments = Array.isArray(story?.segments) ? story.segments : [];\n      segments\n        .filter(seg => (seg.status === 'generating' || seg.status === 'publishing') && !!seg.operation_id)\n        .forEach(seg => startStatusPolling(seg.operation_id));\n    } catch (e) {\n      // no-op\n    }\n  };\n\n  // Context value\n  const contextValue = {\n    ...state,\n    actions: {\n      loadStories,\n      createStory,\n      loadStory,\n      generateVideoSegment,\n      stitchStory,\n      deleteStory,\n      deleteSegment,\n      assistPrompt,\n      clearError: () => dispatch({ type: ActionTypes.CLEAR_ERROR }),\n    }\n  };\n\n  return (\n    <StoryContext.Provider value={contextValue}>\n      {children}\n    </StoryContext.Provider>\n  );\n}\n\n// Hook to use the story context\nexport function useStory() {\n  const context = useContext(StoryContext);\n  if (!context) {\n    throw new Error('useStory must be used within a StoryProvider');\n  }\n  return context;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}